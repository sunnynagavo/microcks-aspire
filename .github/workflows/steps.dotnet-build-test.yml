on:
  workflow_call:
    inputs:
      runs-on:
        required: false
        type: string
        default: 'ubuntu-latest'
      use-sonarcloud:
        required: false
        type: boolean
        default: false
      version:
        required: true
        type: string
      publish-package:
        required: false
        type: boolean
        default: false
    secrets:
      SONAR_TOKEN:
        required: false
    outputs:
      publish-package:
        description: 'Publish package is enabled ?'
        value: ${{ jobs.build_test.outputs.publish-package }}
permissions: read-all

jobs:
  build_test:
    runs-on: ${{ inputs.runs-on }}

    outputs:
      publish-package: ${{ inputs.publish-package }}

    steps:
    - name: 🔄 Checkout
      uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      with:
        lfs: true
        fetch-depth: 0

    - name: 🛠️ Setup .NET
      uses: actions/setup-dotnet@d4c94342e560b34958eacfc5d055d21461ed1c5d # v5.0.0
      with:
        global-json-file: global.json

    - name: 🛠️ Install SonarCloud scanner
      if: ${{ inputs.use-sonarcloud == true }}
      run: dotnet tool install --global dotnet-sonarscanner

    - name: 🔧 Restore .NET Tools
      run: dotnet tool restore

    - name: 🔧 Restore dependencies
      run: dotnet restore

    - name: 🔍 Start SonarQube Analysis
      # Only run SonarCloud analysis only for the original repository and not for forks (either on push or PR from the same repo)
      if: ${{ inputs.use-sonarcloud == true &&
          ( github.repository == 'microcks/microcks-aspire') &&
          ( github.event_name != 'pull_request' || ( github.event.pull_request.head.repo.full_name == github.repository && github.actor != 'dependabot[bot]') ) }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: |
        dotnet-sonarscanner begin `
        /k:"microcks_microcks-aspire" `
        /o:"microcks" `
        /d:sonar.token="${{ secrets.SONAR_TOKEN }}" `
        /d:sonar.host.url="https://sonarcloud.io" `
        /d:sonar.cs.opencover.reportsPaths="**/*.opencover.xml" `
        /d:sonar.cs.vscoveragexml.reportsPaths=coverage.xml `
        /v:"${{ inputs.version }}"
      shell: pwsh

    - name: 🏗 Build
      run: dotnet build --configuration Release --no-restore

    - name: 🧪 Test .NET
      id: test
      if: ${{ inputs.use-sonarcloud == false }}
      run: |
        dotnet test -f net10.0 --no-build `
        --configuration Release `
        --logger "console;verbosity=detailed" `
        --logger trx `
        --collect:"XPlat Code Coverage" `
        --results-directory testresults
      shell: pwsh

    - name: 🧪 Test .NET with coverage
      id: test-with-coverage
      if: ${{ inputs.use-sonarcloud == true }}
      run: |
        dotnet tool install --global dotnet-coverage
        dotnet-coverage collect --output-format xml --output "coverage.xml" "dotnet test --no-build -f net10.0 --configuration Release --logger console;verbosity=detailed --logger trx --results-directory testresults"
      shell: pwsh

    - name: Stop SonarQube Analysis
      # Only run SonarCloud analysis only for the original repository and not for forks (either on push or PR from the same repo)
      if: ${{ inputs.use-sonarcloud == true &&
          ( success() || steps.test-with-coverage.conclusion == 'failure' ) &&
          ( github.repository == 'microcks/microcks-aspire' ) &&
          ( github.event_name != 'pull_request' || ( github.event.pull_request.head.repo.full_name == github.repository && github.actor != 'dependabot[bot]' ) ) }}
      id: sonar
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: |
        dotnet-sonarscanner end /d:sonar.token="${{ secrets.SONAR_TOKEN }}"

    - name: 📤 Upload Test And Coverage Results
      uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
      if: always() # run this step even if previous step failed
      with:
        name: ${{ inputs.runs-on }}
        path: testresults

    - name: 📦 Nuget Pack
      if: ${{ inputs.publish-package }}
      run: |
        dotnet pack `
        --include-source `
        --configuration Release `
        --no-build `
        --no-restore `
        --output ${{ github.workspace }}/nugets/ `
        -p:PackageVersion="${{ inputs.version }}"
      shell: pwsh

    - name: 📤 Upload Nuget Package
      uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
      if: ${{ inputs.publish-package }}
      with:
        if-no-files-found: error
        name: nugets_${{ inputs.runs-on }}
        path: nugets

